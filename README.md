# List of Free Learning Resources

  -: Algorithms and Their Categories :-

# Dynamic Programming:

Fibonacci Series: Calculates Fibonacci numbers using a bottom-up approach.
Longest Common Subsequence (LCS): Finds the longest subsequence common to two sequences.
Knapsack Problem: Maximizes value within a weight limit using items with given weights and values.
Matrix Chain Multiplication: Determines the most efficient way to multiply a chain of matrices.
Shortest Paths in DAG: Finds the shortest paths in a Directed Acyclic Graph.

# String Algorithms:

Pattern Searching:
Naive: Checks all positions in the text.
KMP: Uses a partial match table to skip unnecessary comparisons.
Rabin-Karp: Uses hashing to find patterns quickly [2].
Longest Common Substring: Finds the longest substring common to two strings.
Longest Palindromic Subsequence: Finds the longest subsequence that is a palindrome [1].
Edit Distance: Measures the minimum number of operations required to transform one string into another.

# Mathematical Algorithms:

Prime Number Generation: Generates prime numbers up to a given limit.
Factorial Calculation: Computes the factorial of a number.
GCD (Euclidean Algorithm): Finds the greatest common divisor of two numbers.
Sieve of Eratosthenes: An efficient algorithm to find all primes up to a specified integer.
Fast Exponentiation (Modular Exponentiation): Quickly computes large powers modulo a number.

# Miscellaneous Algorithms:

Backtracking: Systematically searches for solutions by trying and eliminating options.
Greedy Algorithms: Makes the locally optimal choice at each step with the hope of finding the global optimum.
Divide and Conquer: Divides a problem into subproblems, solves them, and combines the results.
Randomized Algorithms: Uses randomness to simplify algorithms or improve performance.

# Sorting Algorithms:

Bubble Sort: Repeatedly swaps adjacent elements if they are in the wrong order.
Selection Sort: Selects the smallest element from an unsorted list and swaps it with the first unsorted element.
Insertion Sort: Builds the final sorted array one item at a time.
Merge Sort: Divides the array into halves, sorts them, and merges them.
Quick Sort: Picks an element as a pivot and partitions the array around it.
Heap Sort: Converts the array into a heap and repeatedly extracts the maximum element.

# Searching Algorithms:

Linear Search: Checks each element of the list until the target value is found.
Binary Search: Repeatedly divides a sorted list in half to find the target value.

# Graph Algorithms:

Breadth-First Search (BFS): Explores the graph layer by layer.
Depth-First Search (DFS): Explores as far as possible along each branch before backtracking.
Shortest Path Algorithms:
Dijkstra's: Finds the shortest path from a source node to all other nodes.
Bellman-Ford: Finds shortest paths from a source node to all nodes in a graph with negative weights.
Minimum Spanning Tree Algorithms:
Prim's: Adds the smallest edge that connects a new vertex to the growing MST.
Kruskal's: Adds edges in order of increasing weight to the MST.
Topological Sorting: Orders vertices such that for every directed edge u -> v, u comes before v.
Strongly Connected Components (SCC): Identifies maximal subgraphs where every vertex is reachable from every other vertex in the subgraph.
![graph18](https://github.com/user-attachments/assets/69b34113-5fd6-48b5-9427-7af0c9c8b26b)



# Tree Algorithms:

Tree Traversal: Visits all nodes in a tree (Inorder, Preorder, Postorder).
Binary Search Tree (BST) Operations: Insertion, deletion, and search operations in a BST.
Lowest Common Ancestor (LCA): Finds the lowest common ancestor of two nodes in a tree.
![Treedatastructure](https://github.com/user-attachments/assets/c57023bd-79aa-4a22-aacf-7b2a34924756)




